#include <sys/types.h>
#include <sys/extattr.h>


static void
split_name(const char list[], size_t size, void (*func)(void *, VALUE), void *userdata)
{
    // Each list entry consists of a single byte containing the length of
    // the attribute name, followed by the attribute name.
    // The attribute name is not terminated by ASCII 0 (nul).
    const char *ptr = list;
    const char *end = list + size;

    while (ptr < end) {
        size_t len = (uint8_t)*ptr ++;
        if (ptr + len > end) { return; }
        func(userdata, rb_str_new(ptr, len));
        ptr += len;
    }
}

static int
get_extattr_list_size(int (*extattr_list)(), intptr_t d, int namespace)
{
    int size = extattr_list(d, namespace, NULL, 0);
    if (size < 0) { rb_sys_fail("extattr_list call error"); }
    return size;
}

static VALUE
extattr_list0(int (*extattr_list)(), intptr_t d, int namespace)
{
    size_t size = get_extattr_list_size(extattr_list, d, namespace);
    VALUE buf = rb_str_buf_new(size);
    char *ptr = RSTRING_PTR(buf);

    ssize_t size1 = extattr_list(d, namespace, ptr, size);
    if (size1 < 0) { rb_sys_fail("extattr_list call error"); }

    VALUE list = Qnil;
    if (rb_block_given_p()) {
        split_name(ptr, size1, (void (*)(void *, VALUE))rb_yield_values, (void *)(1));
    } else {
        list = rb_ary_new();
        split_name(ptr, size1, (void (*)(void *, VALUE))rb_ary_push, (void *)list);
    }
    rb_free_tmp_buffer(&buf);

    return list;
}

static VALUE
file_extattr_list0(VALUE file, int fd, int namespace)
{
    return extattr_list0(extattr_list_fd, fd, namespace);
}

static VALUE
file_s_extattr_list0(VALUE path, int namespace)
{
    return extattr_list0(extattr_list_file, (intptr_t)StringValueCStr(path), namespace);
}

static VALUE
file_s_extattr_list_link0(VALUE path, int namespace)
{
    return extattr_list0(extattr_list_link, (intptr_t)StringValueCStr(path), namespace);
}


static VALUE
extattr_size0(int (*extattr_get)(), intptr_t d, int namespace, VALUE name)
{
    ssize_t size = extattr_get(d, namespace, RSTRING_PTR(name), NULL, 0);
    if (size < 0) { rb_sys_fail("extattr_get call error"); }
    return SIZET2NUM(size);
}

static VALUE
file_extattr_size0(VALUE file, int fd, int namespace, VALUE name)
{
    return extattr_size0(extattr_get_fd, fd, namespace, name);
}

static VALUE
file_s_extattr_size0(VALUE path, int namespace, VALUE name)
{
    return extattr_size0(extattr_get_file, (intptr_t)StringValueCStr(path), namespace, name);
}

static VALUE
file_s_extattr_size_link0(VALUE path, int namespace, VALUE name)
{
    return extattr_size0(extattr_get_link, (intptr_t)StringValueCStr(path), namespace, name);
}


static VALUE
extattr_get0(int (*extattr_get)(), intptr_t d, VALUE path, int namespace, VALUE name)
{
    ssize_t size = extattr_get(d, namespace, RSTRING_PTR(name), NULL, 0);
    if (size < 0) { rb_sys_fail(StringValueCStr(path)); }
    VALUE buf = rb_str_buf_new(size);
    size = extattr_get(d, namespace, RSTRING_PTR(name), RSTRING_PTR(buf), size);
    if (size < 0) { rb_sys_fail(StringValueCStr(path)); }
    rb_str_set_len(buf, size);
    return buf;
}

static VALUE
file_extattr_get0(VALUE file, int fd, int namespace, VALUE name)
{
    return extattr_get0(extattr_get_fd, fd, RFILE(file)->fptr->pathv, namespace, name);
}

static VALUE
file_s_extattr_get0(VALUE path, int namespace, VALUE name)
{
    return extattr_get0(extattr_get_file, (intptr_t)StringValueCStr(path), path, namespace, name);
}

static VALUE
file_s_extattr_get_link0(VALUE path, int namespace, VALUE name)
{
    return extattr_get0(extattr_get_link, (intptr_t)StringValueCStr(path), path, namespace, name);
}


static VALUE
extattr_set0(int (*extattr_set)(), intptr_t d, int namespace, VALUE name, VALUE data)
{
    int status = extattr_set(d, namespace, RSTRING_PTR(name), RSTRING_PTR(data), RSTRING_LEN(data));
    if (status < 0) { rb_sys_fail("extattr_set call error"); }
    return Qnil;
}

static VALUE
file_extattr_set0(VALUE file, int fd, int namespace, VALUE name, VALUE data)
{
    return extattr_set0(extattr_set_fd, fd, namespace, name, data);
}

static VALUE
file_s_extattr_set0(VALUE path, int namespace, VALUE name, VALUE data)
{
    return extattr_set0(extattr_set_file, (intptr_t)StringValueCStr(path), namespace, name, data);
}

static VALUE
file_s_extattr_set_link0(VALUE path, int namespace, VALUE name, VALUE data)
{
    return extattr_set0(extattr_set_link, (intptr_t)StringValueCStr(path), namespace, name, data);
}


static VALUE
extattr_delete0(int (*extattr_delete)(), intptr_t d, int namespace, VALUE name)
{
    int status = extattr_delete(d, namespace, RSTRING_PTR(name), NULL, 0);
    if (status < 0) { rb_sys_fail("extattr_delete call error"); }
    return Qnil;
}

static VALUE
file_extattr_delete0(VALUE file, int fd, int namespace, VALUE name)
{
    return extattr_delete0(extattr_delete_fd, fd, namespace, name);
}

static VALUE
file_s_extattr_delete0(VALUE path, int namespace, VALUE name)
{
    return extattr_delete0(extattr_delete_file, (intptr_t)StringValueCStr(path), namespace, name);
}

static VALUE
file_s_extattr_delete_link0(VALUE path, int namespace, VALUE name)
{
    return extattr_delete0(extattr_delete_link, (intptr_t)StringValueCStr(path), namespace, name);
}


static void
setup(void)
{
}
